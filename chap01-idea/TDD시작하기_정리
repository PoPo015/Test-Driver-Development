2장

TDD 흐름 - 테스트 -> 코딩 -> 리팩토링 // 레드 - 그린 - 리팩터

테스트가 개발을 주도. 지속적인 코드정리. 빠른피드백 가능


3장

초반에 복잡한 테스트부터시작 X 구현하기 쉬운 테스트부터 시작하기 O

예외 상황을 먼저 테스트 하자. / 테스트를 통과한뒤에는 리팩토링 진행

테스트 작성순서연습
- 테스트 클래스 이름 정하기. / 파라미터가 많아질수록 가독성이 안좋으니 객체로 넘길것을 고려해볼것.
- 테스트할 목록을 미리 정리하면 좋다. / 모든걸 한번에 테스트 하려고하면 너무방대하고 오래걸리니 간단하게 생각나는거 위주로 먼저하고, 테스트구현은 쉬운거부터 구현
- 시작이 안될때는 단언부터 고민하자.
- TDD를 진행하다보면 구현이 막힐때가있다. 잘못한거같은느낌이 들거나할땐 과감하게 지우고 다시 시작하자.

4장 TDD*기능 명세 설계
- 설계는 기능명세로부터 시작한다.(요구사항 문서를 이용해서 기능명세를 구체화한다.)
- 설계 과정을 지원하는 TDD (TDD를하다보면 테스트 코드를 작성하는과정에서 일부 설계를 진행하게된다)
                          1.테스트의 대상이 될 클래스 이름 선정
                          2. 호출할 메서드 선정
                          3. 호출한 메서드의 리턴타입 선정
                          4. 실행결과
- 필요한 만큼 설계하기 (필요할것으로 예측해서 미리코드를 만들지않는다.필요한 시점에 추가한다.)
- 기능 명세정리 (요구사항문서에 생략된게 많으니, 기능의 입력과 결과를 도출해서 기능 명세를 구체화해야함.)
- TDD는 처음접하는 보드게임과 같다. 보드게임의 규칙을 들었다고해서, 바로 완벽하게 이해하는게 아니다. 게임을진행하며 다양한 상황에 적용하다가 이해한다 TDD도 이와 유사하다.

5장 JUnit 5 기초
* 각테스트 메서드는 순서를 줄수 있지만, 각테스트 메서드는 서로 독립적으로 동작해야함. 한 테스트 메서드의 결과에 따라 다른 테스트 메서드의 실행결과가 달라지면 안된다.
- 크게 세개의 요소로 구성 되어 있다.
 1) Junit 플랫폼 - 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API 제공
 2) junit 주피터(Jupiter) - JUnit 5를 위한 테스트 API와 실행 엔진제공
 3) Junit 빈티지(Vintage) - Junit 3과 4로 작성된 테스트를 Junit 플랫폼에서 실행하기 위한 모듈제공

 @Test - 가장 기본적인 테스트 코드를 작성하고 실행시킬수 있는 어노테이션
 Assertions 클래스- 기본적인 단언 주요 메서드를 갖고있다.
 @DisplayName - 메서드의 이름에 공백이나 특수문자를 사용하고싶을때 사용.
 @Disabled - 한 클래스내에서 특정테스트를 실행시키고 싶지않을때 사용.(테스트 실행 대상에서 제외)

 @BeforeEach - 테스트 메서드의 시작전 실행시킬 메소드 (보통 임시파일을 생성할떄 사용)
 @AfterEach - 테스트 메서드의 시작후 실행시킬 메소드 (보통 임시파일을 삭제할때사용)
 ( 한클래스의 모든테스트 메서드가 동일한 작업이필요하다면 @BeforeEachAll , @AfterEachAll )

** 개발하는 과정에서 특정 클래스나 메서드 단위로 실행하지만, 코드를 깃에 푸시하거나 운영환경에 배포할땐 모든 테스트를 실행해서 꺠지는 테스트가없는지 확인.**

6장 테스트 코드의 구성
테스트 코드는 기능을 실행하고 그결과를 확인하므로 상황,실행,결과 확인의 세가지 요소로 테스트를 구성할수있다.
(어떠한 상황이 주어지고, 그상황에서 기능을 실행하고, 실행한결과를 확인하는 세가지가 테스트코드의 기본골격을 이루게된다) given - when - then
(상황 - 실행 - 결과 확인 구조에 너무 집착은 하지말자, 도움이 되는건 맞지만 모든 테스트를 이런구조로 만들어야하는것은아니다.)

외부 상황과 결과 - 파일에 대한 테스트를 진행할때나 우연으로 테스트가 성공할수 있을땐 , 확실한 방법으로 명시적으로 파일이없는 상황을 만드는것이다.
                (파일 테스트를 기준으론 src/test/resourec 안에 다 넣어두고, 굳이 폴더를 뒤져가며 테스트안할수있게 편하게 작업하자.)
                (우연적으로 성공하거나 이런경우는 예외가 발생할수 있으니 명시적으로 실패 코드, 성공 코드를 만들자)


외부 상태가 테스트 결과에 영향을 주지않게하기 - TDD를 실행하고 개발이 끝난이후 반복테스트를 통해 문제가없는지 검증한다. 그렇기떄문에 테스트는 언제 실행해도
                                        문제없게 동작하도록 해야한다.(트랜잭션을 사용해 롤백하는방법이 있다.)


외부 상태와 테스트 어려움 - 상황에 결과에 영향을 주는 외부요인은 파일,DBMS, 외부 서버 등 다양하다.
                        (테스트 대상이 아닌, 외부 요인은 테스트코드에서 다루기 힘든 존재이다. 이럴떈 *대역*을 통해 외부상황이나 결과를 대체할수있다)


7장 대역
외부요인은 테스트 작성을 어렵게 만들뿐만 아니라 테스트 결과를 예측할수 없게 만든다.

* 대역의 종류
 1) 스텁(Stub) - 구현을 단순한것으로 대체. 테스트에 맞게 단순히 원하는 동작을 수행한다.
 2) 가짜(Fake) - 제품에는 적합하지않지만, 실제동작하는 구현을 제공
 3) 스파이(Spy) - 호출된 내역을 기록. 기록한 내용은 테스트 결과를 검증할떄 사용
 4) 모의(Mock) - 기대한대로 상호작용하는지 행위를 검증한다. 기대한대로 동작하지않으면 익셉션 발생가능. 스텁이자 스파이도된다.



부록 C Mockitor 기초 사용법
Mockitor는 모의 객체 생성, 검증, 스텁을 지원하는 프레임워크다.
(mockitor-core 모듈을 의존추가)

* Mockitor.mock() 메서드를 이용하면 특정타입의 모의객체를 생성할수있다.
(클래스, 인터페이스, 추상 클래스 에대해 모의 객체 생성가능)

* 스텁 설정
모의 객체를 생성한뒤엔 BDDMockitor 클래스를 이용해서 모의 객체에 스텁을 구성할수있다.
예를들어 BDDMockitor.given()메서드를 이용하면 모의 객체의 메서드가 특정값을 리턴하도록 설정할수있음.
// genMock.generate(GameLevel.EASY)가 불리면 "123"을 리턴하라 라는 설정
// given(genMock.generate(GameLevel.EASY)).willReturn("123");

- 리턴 타입이 void인 메서드에 대해 익셉션을 발생하려면 BDDMockitor.willThorw()메서드 사용
- Mockitor는 일치하는 스텁 설정이 없을경우 리턴타입의 기본값을 리턴한다.
 (예를 들어 리턴타입이 int면 0을 리턴하고 boolean이면 false를 리턴한다. 참조형 데이터타입이면 null 리턴)
- ArgumentMatchers 클래스를 사용하면 정확하게 일치하는값 대신 임의의값에 일치하도록 설정할수있음.


* 행위검증
- 실제로 모의 객체가 불렸는지 검증하는것.
- BDDMockitor.then()는 메서드 호출 여부를 검증할 모의객체를 전달받음
- should()메서드는 모의 객체의 메서드가 불려야한다는것을 설정하고, shold() 메서드 다음에 실제로 불려야할 메서드를 지정한다.
- genMock 모의 객체의 generater() 메서드가 GameLevele.EASY 인자를 사용해서 호출되었는지 검증한다.


* 인자 캡쳐
- 객체를 호출할떄 사용한 인자를 검증해야할떄, 많은 속성을 가진 객체를 쉽게 검증하기 위한 방법
